events <- noncumul.eventlog$get.events(event.name)
if (event.name == 'transmission') {
# find the longest path from root to tip
root <- setdiff(events$compartment2, events$compartment1)
tips <- setdiff(events$compartment1, events$compartment2)
maxTime <- private$find.max.time(events, root, tips)
# trace from root to tips and calculate all subsequent cumulative times based on maxTime (end time of transmission tree simulation)
self$events <- rbind(self$events, private$generate.events(events, maxTime, root, tips), stringsAsFactors=F)
} else {
# set of events and their times remain the same, since they are inputted as cumulative time already
NULL
}
})
}
e$get.all.events()
self$events.noncumul
file
e <- EventLogger$new()
sapply(1:nrow(file), function(x) {
e$add.event(name=file[x,'event.type'],
time=file[x,'time'],
obj1=file[x,'lineage1'],
obj2=file[x,'compartment1'],
obj3=file[x,'compartment2'])
})
e$get.all.events(cumulative = F)
self$events.noncumul
rm(self)
e$events.noncumul
e$events
EventLogger <- R6Class("EventLogger",
public = list(
events = NULL,
events.noncumul = NULL,
initialize = function(events = data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
),
events.noncumul = data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
)
{
self$events <- events
self$events.noncumul <- events.noncumul
},
get.all.events = function(cumulative=TRUE) {
if (nrow(self$events.noncumul) == 0) {cat('No events to display.')}
else {
if (cumulative) {
.generate.cumul.eventlog(self$events.noncumul)                        # default eventlog shows cumulative time b/c more user friendly
#self$events
} else {
self$events.noncumul
}
}
},
.generate.cumul.eventlog = function(noncumul.eventlog) {
self$events <- data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
event.types <- unique(noncumul.eventlog$event.type)        # up to 3 different event types
sapply(event.types, function(event.name) {
# for each type of event (transmission, migration, and/or coalescent)
# retrieve set of events of that event.name type
events <- noncumul.eventlog$get.events(event.name)
if (event.name == 'transmission') {
# find the longest path from root to tip
root <- setdiff(events$compartment2, events$compartment1)
tips <- setdiff(events$compartment1, events$compartment2)
maxTime <- private$find.max.time(events, root, tips)
# trace from root to tips and calculate all subsequent cumulative times based on maxTime (end time of transmission tree simulation)
self$events <- rbind(self$events, private$generate.events(events, maxTime, root, tips), stringsAsFactors=F)
} else {
# set of events and their times remain the same, since they are inputted as cumulative time already
NULL
}
})
self$events
},
get.events = function(event.type) {
eventList <- self$events.noncumul
indices <- which(eventList$event.type == event.type)
if (length(indices) != 0) {
as.data.frame(t(sapply(indices, function(x) {eventList[x,]})))
} else {NULL}
},
add.event = function(name, time, obj1, obj2, obj3) {
# @param name = event type of either transmission, migration, or coalescent
# @param time = NON-CUMULATIVE time that event has occurred between two compartments in a transmission/migration event,
# or CUMULATIVE time that event has occurred in a coalescent event   -------------MAY CHANGE IN FUTURE
# @param obj1 = name of a lineage object in mode character
if (tolower(name) == 'transmission' || tolower(name) == 'migration') {
nonCumulEvent <- list(event.type=name, time=time, lineage1=obj1, lineage2=NA, compartment1=obj2, compartment2=obj3)
} else if (tolower(name) == 'coalescent') {
nonCumulEvent <- list(event.type=name, time=time, lineage1=obj1, lineage2=obj2, compartment1=obj3, compartment2=NA)
}
self$events.noncumul <- rbind(self$events.noncumul, nonCumulEvent, stringsAsFactors=F)
},
clear.events = function() {
self$events = self$events.noncumul <- data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
}
),
private = list(
find.max.time = function(events, root, tips) {
# @oaram events = set of events of a particular type (ie. transmission, migration, coalescent)
# @return maxTime = maximum cumulative time of longest path from root to tip; the 'time span' of the transmission tree simulation
maxTime <- 0
# recursive function to calculate cumulative time
calc.cumul.time <- function(node, node_time) {
parent <- events[ which(events$compartment1 == node), 'compartment2']
if (parent == root) {
return (node_time)
} else {
parent_time <- events[ which(events$compartment1 == parent), 'time']
return (node_time + calc.cumul.time(parent, parent_time))
}
}
# for each tip, trace back and calculate resulting cumulative time at the root
for (tip in tips) {
tip_time <- events[ which(events$compartment1 == tip), 'time']
cumul.time <- calc.cumul.time(tip, tip_time)
if (cumul.time > maxTime) {
maxTime <- cumul.time
}
}
maxTime
},
generate.events = function(events, maxTime, root, tips) {
generate.indiv.event <- function(node, parent_time) {
# recursive function to generate cumulative times for each individual event
# returns a childEvent or NULL to be added to the eventlog data frame
if (node %in% tips) {
return (NULL)
} else {
nodeEvents <- events[ which(events$compartment2 == node), ]
if (length(row.names(nodeEvents)) == 0) {
return(NULL)
} else {
for (x in seq_along(nodeEvents)) {
childEvent <- nodeEvents[x,]
childEvent['time'] <- parent_time - childEvent['time']
self$events <- rbind(self$events, childEvent, stringsAsFactors=F)
# same for the descendants
generate.indiv.event(as.character(childEvent['compartment1']), childEvent['time'])
}
return(self$events)
}
}
}
rootEvents <- events[ which(events$compartment2 == root), ]
for (x in seq_along(rootEvents)) {
parentEvent <- rootEvents[x,]
parentEvent['time'] <- maxTime - parentEvent['time']
self$events <- rbind(self$events, parentEvent, stringsAsFactors=F)
# do the same for all of the descendants
generate.indiv.event(as.character(parentEvent['compartment1']), parentEvent['time'])
}
indices <- grep('NA', row.names(self$events), ignore.case=T, invert=T)
#match.noncumul.ordering <- order(row.names(self$events[indices,]))
self$events[indices,]
}
)
)
e <- EventLogger$new()
sapply(1:nrow(file), function(x) {
e$add.event(name=file[x,'event.type'],
time=file[x,'time'],
obj1=file[x,'lineage1'],
obj2=file[x,'compartment1'],
obj3=file[x,'compartment2'])
})
e$get.all.events()
EventLogger <- R6Class("EventLogger",
public = list(
events = NULL,
events.noncumul = NULL,
initialize = function(events = data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
),
events.noncumul = data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
)
{
self$events <- events
self$events.noncumul <- events.noncumul
},
get.all.events = function(cumulative=TRUE) {
if (nrow(self$events.noncumul) == 0) {cat('No events to display.')}
else {
if (cumulative) {
.generate.cumul.eventlog(noncumul.eventlog=self$events.noncumul)                        # default eventlog shows cumulative time b/c more user friendly
#self$events
} else {
self$events.noncumul
}
}
},
.generate.cumul.eventlog = function(noncumul.eventlog) {
self$events <- data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
event.types <- unique(noncumul.eventlog$event.type)        # up to 3 different event types
sapply(event.types, function(event.name) {
# for each type of event (transmission, migration, and/or coalescent)
# retrieve set of events of that event.name type
events <- noncumul.eventlog$get.events(event.name)
if (event.name == 'transmission') {
# find the longest path from root to tip
root <- setdiff(events$compartment2, events$compartment1)
tips <- setdiff(events$compartment1, events$compartment2)
maxTime <- private$find.max.time(events, root, tips)
# trace from root to tips and calculate all subsequent cumulative times based on maxTime (end time of transmission tree simulation)
self$events <- rbind(self$events, private$generate.events(events, maxTime, root, tips), stringsAsFactors=F)
} else {
# set of events and their times remain the same, since they are inputted as cumulative time already
NULL
}
})
self$events
},
get.events = function(event.type) {
eventList <- self$events.noncumul
indices <- which(eventList$event.type == event.type)
if (length(indices) != 0) {
as.data.frame(t(sapply(indices, function(x) {eventList[x,]})))
} else {NULL}
},
add.event = function(name, time, obj1, obj2, obj3) {
# @param name = event type of either transmission, migration, or coalescent
# @param time = NON-CUMULATIVE time that event has occurred between two compartments in a transmission/migration event,
# or CUMULATIVE time that event has occurred in a coalescent event   -------------MAY CHANGE IN FUTURE
# @param obj1 = name of a lineage object in mode character
if (tolower(name) == 'transmission' || tolower(name) == 'migration') {
nonCumulEvent <- list(event.type=name, time=time, lineage1=obj1, lineage2=NA, compartment1=obj2, compartment2=obj3)
} else if (tolower(name) == 'coalescent') {
nonCumulEvent <- list(event.type=name, time=time, lineage1=obj1, lineage2=obj2, compartment1=obj3, compartment2=NA)
}
self$events.noncumul <- rbind(self$events.noncumul, nonCumulEvent, stringsAsFactors=F)
},
clear.events = function() {
self$events = self$events.noncumul <- data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
}
),
private = list(
find.max.time = function(events, root, tips) {
# @oaram events = set of events of a particular type (ie. transmission, migration, coalescent)
# @return maxTime = maximum cumulative time of longest path from root to tip; the 'time span' of the transmission tree simulation
maxTime <- 0
# recursive function to calculate cumulative time
calc.cumul.time <- function(node, node_time) {
parent <- events[ which(events$compartment1 == node), 'compartment2']
if (parent == root) {
return (node_time)
} else {
parent_time <- events[ which(events$compartment1 == parent), 'time']
return (node_time + calc.cumul.time(parent, parent_time))
}
}
# for each tip, trace back and calculate resulting cumulative time at the root
for (tip in tips) {
tip_time <- events[ which(events$compartment1 == tip), 'time']
cumul.time <- calc.cumul.time(tip, tip_time)
if (cumul.time > maxTime) {
maxTime <- cumul.time
}
}
maxTime
},
generate.events = function(events, maxTime, root, tips) {
generate.indiv.event <- function(node, parent_time) {
# recursive function to generate cumulative times for each individual event
# returns a childEvent or NULL to be added to the eventlog data frame
if (node %in% tips) {
return (NULL)
} else {
nodeEvents <- events[ which(events$compartment2 == node), ]
if (length(row.names(nodeEvents)) == 0) {
return(NULL)
} else {
for (x in seq_along(nodeEvents)) {
childEvent <- nodeEvents[x,]
childEvent['time'] <- parent_time - childEvent['time']
self$events <- rbind(self$events, childEvent, stringsAsFactors=F)
# same for the descendants
generate.indiv.event(as.character(childEvent['compartment1']), childEvent['time'])
}
return(self$events)
}
}
}
rootEvents <- events[ which(events$compartment2 == root), ]
for (x in seq_along(rootEvents)) {
parentEvent <- rootEvents[x,]
parentEvent['time'] <- maxTime - parentEvent['time']
self$events <- rbind(self$events, parentEvent, stringsAsFactors=F)
# do the same for all of the descendants
generate.indiv.event(as.character(parentEvent['compartment1']), parentEvent['time'])
}
indices <- grep('NA', row.names(self$events), ignore.case=T, invert=T)
#match.noncumul.ordering <- order(row.names(self$events[indices,]))
self$events[indices,]
}
)
)
e <- EventLogger$new()
sapply(1:nrow(file), function(x) {
e$add.event(name=file[x,'event.type'],
time=file[x,'time'],
obj1=file[x,'lineage1'],
obj2=file[x,'compartment1'],
obj3=file[x,'compartment2'])
})
e$get.all.events()
EventLogger <- R6Class("EventLogger",
public = list(
events = NULL,
events.noncumul = NULL,
initialize = function(events = data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
),
events.noncumul = data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
)
{
self$events <- events
self$events.noncumul <- events.noncumul
},
get.all.events = function(cumulative=TRUE) {
if (nrow(self$events.noncumul) == 0) {cat('No events to display.')}
else {
if (cumulative) {
noncumul.eventlog <- self$events.noncumul
.generate.cumul.eventlog(noncumul.eventlog)                        # default eventlog shows cumulative time b/c more user friendly
#self$events
} else {
self$events.noncumul
}
}
},
.generate.cumul.eventlog = function(noncumul.eventlog) {
self$events <- data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
event.types <- unique(noncumul.eventlog$event.type)        # up to 3 different event types
sapply(event.types, function(event.name) {
# for each type of event (transmission, migration, and/or coalescent)
# retrieve set of events of that event.name type
events <- noncumul.eventlog$get.events(event.name)
if (event.name == 'transmission') {
# find the longest path from root to tip
root <- setdiff(events$compartment2, events$compartment1)
tips <- setdiff(events$compartment1, events$compartment2)
maxTime <- private$find.max.time(events, root, tips)
# trace from root to tips and calculate all subsequent cumulative times based on maxTime (end time of transmission tree simulation)
self$events <- rbind(self$events, private$generate.events(events, maxTime, root, tips), stringsAsFactors=F)
} else {
# set of events and their times remain the same, since they are inputted as cumulative time already
NULL
}
})
self$events
},
get.events = function(event.type) {
eventList <- self$events.noncumul
indices <- which(eventList$event.type == event.type)
if (length(indices) != 0) {
as.data.frame(t(sapply(indices, function(x) {eventList[x,]})))
} else {NULL}
},
add.event = function(name, time, obj1, obj2, obj3) {
# @param name = event type of either transmission, migration, or coalescent
# @param time = NON-CUMULATIVE time that event has occurred between two compartments in a transmission/migration event,
# or CUMULATIVE time that event has occurred in a coalescent event   -------------MAY CHANGE IN FUTURE
# @param obj1 = name of a lineage object in mode character
if (tolower(name) == 'transmission' || tolower(name) == 'migration') {
nonCumulEvent <- list(event.type=name, time=time, lineage1=obj1, lineage2=NA, compartment1=obj2, compartment2=obj3)
} else if (tolower(name) == 'coalescent') {
nonCumulEvent <- list(event.type=name, time=time, lineage1=obj1, lineage2=obj2, compartment1=obj3, compartment2=NA)
}
self$events.noncumul <- rbind(self$events.noncumul, nonCumulEvent, stringsAsFactors=F)
},
clear.events = function() {
self$events = self$events.noncumul <- data.frame(event.type=character(),
time=numeric(),
lineage1=character(),
lineage2=character(),
compartment1=character(),
compartment2=character()
)
}
),
private = list(
find.max.time = function(events, root, tips) {
# @oaram events = set of events of a particular type (ie. transmission, migration, coalescent)
# @return maxTime = maximum cumulative time of longest path from root to tip; the 'time span' of the transmission tree simulation
maxTime <- 0
# recursive function to calculate cumulative time
calc.cumul.time <- function(node, node_time) {
parent <- events[ which(events$compartment1 == node), 'compartment2']
if (parent == root) {
return (node_time)
} else {
parent_time <- events[ which(events$compartment1 == parent), 'time']
return (node_time + calc.cumul.time(parent, parent_time))
}
}
# for each tip, trace back and calculate resulting cumulative time at the root
for (tip in tips) {
tip_time <- events[ which(events$compartment1 == tip), 'time']
cumul.time <- calc.cumul.time(tip, tip_time)
if (cumul.time > maxTime) {
maxTime <- cumul.time
}
}
maxTime
},
generate.events = function(events, maxTime, root, tips) {
generate.indiv.event <- function(node, parent_time) {
# recursive function to generate cumulative times for each individual event
# returns a childEvent or NULL to be added to the eventlog data frame
if (node %in% tips) {
return (NULL)
} else {
nodeEvents <- events[ which(events$compartment2 == node), ]
if (length(row.names(nodeEvents)) == 0) {
return(NULL)
} else {
for (x in seq_along(nodeEvents)) {
childEvent <- nodeEvents[x,]
childEvent['time'] <- parent_time - childEvent['time']
self$events <- rbind(self$events, childEvent, stringsAsFactors=F)
# same for the descendants
generate.indiv.event(as.character(childEvent['compartment1']), childEvent['time'])
}
return(self$events)
}
}
}
rootEvents <- events[ which(events$compartment2 == root), ]
for (x in seq_along(rootEvents)) {
parentEvent <- rootEvents[x,]
parentEvent['time'] <- maxTime - parentEvent['time']
self$events <- rbind(self$events, parentEvent, stringsAsFactors=F)
# do the same for all of the descendants
generate.indiv.event(as.character(parentEvent['compartment1']), parentEvent['time'])
}
indices <- grep('NA', row.names(self$events), ignore.case=T, invert=T)
#match.noncumul.ordering <- order(row.names(self$events[indices,]))
self$events[indices,]
}
)
)
e <- EventLogger$new()
sapply(1:nrow(file), function(x) {
e$add.event(name=file[x,'event.type'],
time=file[x,'time'],
obj1=file[x,'lineage1'],
obj2=file[x,'compartment1'],
obj3=file[x,'compartment2'])
})
e$get.all.events()
require(R6)
