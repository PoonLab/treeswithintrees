# go to next piece and draw new waiting time
} else {
cumul.wait.time <- overall.t - delta.t
waiting.times <- c(waiting.times, cumul.wait.time)                # add the waiting time of current compartment to the vector of waiting times
names(waiting.times)[[length(waiting.times)]] <- compname         # associate the waiting times with their compartments
break
}
}
}
return(waiting.times)
}
coal.wait.times <- calc.coal.wait.times(model, current.time)
comps <- model$get.compartments()
compnames <- model$get.names(comps)
extant_comps <- unique(sapply(
unname(model$get.pairs()),
function(x) {
comps[[which(compnames == x)]]
}
))
ext.lineages.compnames <- sapply(
model$get.extant_lineages(current.time),
function(x) {
x$get.location()$get.name()
}
)
num.ext.lineages <- function(x) {
length(which(ext.lineages.compnames==x))
}
waiting.times <- vector()
for (comp in extant_comps){
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
pieces <- popn.growth[which(popn.growth[,'time'] < time),]            # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
for (i in nrow(pieces):1){
# iterate through the valid pieces of population growth dynamics to draw waiting time
# in forward time, start at the current piece first and work backwards to earlier pieces in the popn.growth dynamic fxns (if needed)
piece <- pieces[i,]
wait <- wait.time(num.ext.lineages(compname), piece['intercept'], piece['slope'])
delta.t <- delta.t - wait
# if waiting time exceeds the start time of the piece, move delta.t to the start time (end time of the previous piece)
if (delta.t < piece['time']){
delta.t <- piece['time']
if (delta.t == 0) {
waiting.times <- c(waiting.times, overall.t)                    # wait time 'maxed out', add total waiting time from current time
names(waiting.times)[[length(waiting.times)]] <- compname       # associate waiting times w/ their compartment name
}
# go to next piece and draw new waiting time
} else {
cumul.wait.time <- overall.t - delta.t
waiting.times <- c(waiting.times, cumul.wait.time)                # add the waiting time of current compartment to the vector of waiting times
names(waiting.times)[[length(waiting.times)]] <- compname         # associate the waiting times with their compartments
break
}
}
}
waiting.times <- vector()
extant_comps
comp <- extant_comps[[1]]
comp
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
pieces <- popn.growth[which(popn.growth[,'time'] < time),]            # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
popn.growth
delta.t
overall.t
which(popn.growth[,'time'] < time)
calc.coal.wait.times <- function(model, current.time){
# draw waiting times for all compartments that have two or more extant lineages
# @param model = MODEL object
# @return waiting.times = vector of waiting times
comps <- model$get.compartments()
compnames <- model$get.names(comps)
# retrieves compartments with multiple extant lineages
extant_comps <- unique(sapply(
unname(model$get.pairs()),
function(x) {
comps[[which(compnames == x)]]
}
))
# retrieves compartment names for extant lineages
ext.lineages.compnames <- sapply(
model$get.extant_lineages(current.time),
function(x) {
x$get.location()$get.name()
}
)
# counts the number of extant lineages in one compartment
# calculated for parameter `k` in function `wait.time`
num.ext.lineages <- function(x) {
length(which(ext.lineages.compnames==x))
}
# initialize an empty vector for waiting times
waiting.times <- vector()
for (comp in extant_comps){
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
pieces <- popn.growth[which(popn.growth[,'time'] < delta.t),]            # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
for (i in nrow(pieces):1){
# iterate through the valid pieces of population growth dynamics to draw waiting time
# in forward time, start at the current piece first and work backwards to earlier pieces in the popn.growth dynamic fxns (if needed)
piece <- pieces[i,]
wait <- wait.time(num.ext.lineages(compname), piece['intercept'], piece['slope'])
delta.t <- delta.t - wait
# if waiting time exceeds the start time of the piece, move delta.t to the start time (end time of the previous piece)
if (delta.t < piece['time']){
delta.t <- piece['time']
if (delta.t == 0) {
waiting.times <- c(waiting.times, overall.t)                    # wait time 'maxed out', add total waiting time from current time
names(waiting.times)[[length(waiting.times)]] <- compname       # associate waiting times w/ their compartment name
}
# go to next piece and draw new waiting time
} else {
cumul.wait.time <- overall.t - delta.t
waiting.times <- c(waiting.times, cumul.wait.time)                # add the waiting time of current compartment to the vector of waiting times
names(waiting.times)[[length(waiting.times)]] <- compname         # associate the waiting times with their compartments
break
}
}
}
return(waiting.times)
}
coal.wait.times <- calc.coal.wait.times(model, current.time)
comps <- model$get.compartments()
compnames <- model$get.names(comps)
extant_comps <- unique(sapply(
unname(model$get.pairs()),
function(x) {
comps[[which(compnames == x)]]
}
))
ext.lineages.compnames <- sapply(
model$get.extant_lineages(current.time),
function(x) {
x$get.location()$get.name()
}
)
num.ext.lineages <- function(x) {
length(which(ext.lineages.compnames==x))
}
waiting.times <- vector()
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
pieces <- popn.growth[which(popn.growth[,'time'] < delta.t),]            # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
pieces
nrow(pieces)
nrow(pieces)
typeof(pieces)
pieces <- popn.growth[which(popn.growth[,'time'] < 50),]
pieces
pieces <- popn.growth[which(popn.growth[,'time'] < 10),]
pieces
pieces <- popn.growth[which(popn.growth[,'time'] < 4),]
pieces
pieces <- as.matrix(popn.growth[which(popn.growth[,'time'] < 4),])
pieces
pieces <- as.matrix(t(popn.growth[which(popn.growth[,'time'] < 4),])  )
pieces
comps <- model$get.compartments()
compnames <- model$get.names(comps)
extant_comps <- unique(sapply(
unname(model$get.pairs()),
function(x) {
comps[[which(compnames == x)]]
}
))
ext.lineages.compnames <- sapply(
model$get.extant_lineages(current.time),
function(x) {
x$get.location()$get.name()
}
)
num.ext.lineages <- function(x) {
length(which(ext.lineages.compnames==x))
}
waiting.times <- vector()
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
piece.rows <- which(popn.growth[,'time'] < delta.t)
if (length(piece.rows) == 1) {
pieces <- as.matrix(t(popn.growth[piece.rows, ]))                   # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
} else {
pieces <- popn.growth[piece.rows, ]
}
pieces
comps <- model$get.compartments()
compnames <- model$get.names(comps)
extant_comps <- unique(sapply(
unname(model$get.pairs()),
function(x) {
comps[[which(compnames == x)]]
}
))
ext.lineages.compnames <- sapply(
model$get.extant_lineages(current.time),
function(x) {
x$get.location()$get.name()
}
)
num.ext.lineages <- function(x) {
length(which(ext.lineages.compnames==x))
}
waiting.times <- vector()
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
piece.rows <- which(popn.growth[,'time'] < delta.t)
if (length(piece.rows) == 1) {
pieces <- as.matrix(t(popn.growth[piece.rows, ]))                   # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
rownames(pieces) <- 1
} else {
pieces <- popn.growth[piece.rows, ]
}
pieces
nrow(pieces)
for (i in nrow(pieces):1){
# iterate through the valid pieces of population growth dynamics to draw waiting time
# in forward time, start at the current piece first and work backwards to earlier pieces in the popn.growth dynamic fxns (if needed)
piece <- pieces[i,]
wait <- wait.time(num.ext.lineages(compname), piece['intercept'], piece['slope'])
delta.t <- delta.t - wait
# if waiting time exceeds the start time of the piece, move delta.t to the start time (end time of the previous piece)
if (delta.t < piece['time']){
delta.t <- piece['time']
if (delta.t == 0) {
waiting.times <- c(waiting.times, overall.t)                    # wait time 'maxed out', add total waiting time from current time
names(waiting.times)[[length(waiting.times)]] <- compname       # associate waiting times w/ their compartment name
}
# go to next piece and draw new waiting time
} else {
cumul.wait.time <- overall.t - delta.t
waiting.times <- c(waiting.times, cumul.wait.time)                # add the waiting time of current compartment to the vector of waiting times
names(waiting.times)[[length(waiting.times)]] <- compname         # associate the waiting times with their compartments
break
}
}
comps <- model$get.compartments()
compnames <- model$get.names(comps)
extant_comps <- unique(sapply(
unname(model$get.pairs()),
function(x) {
comps[[which(compnames == x)]]
}
))
ext.lineages.compnames <- sapply(
model$get.extant_lineages(current.time),
function(x) {
x$get.location()$get.name()
}
)
num.ext.lineages <- function(x) {
length(which(ext.lineages.compnames==x))
}
waiting.times <- vector()
for (comp in extant_comps){
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
piece.rows <- which(popn.growth[,'time'] < delta.t)
if (length(piece.rows) == 1) {
pieces <- as.matrix(t(popn.growth[piece.rows, ]))                   # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
rownames(pieces) <- 1
} else {
pieces <- popn.growth[piece.rows, ]
}
for (i in nrow(pieces):1){
# iterate through the valid pieces of population growth dynamics to draw waiting time
# in forward time, start at the current piece first and work backwards to earlier pieces in the popn.growth dynamic fxns (if needed)
piece <- pieces[i,]
wait <- wait.time(num.ext.lineages(compname), piece['intercept'], piece['slope'])
delta.t <- delta.t - wait
# if waiting time exceeds the start time of the piece, move delta.t to the start time (end time of the previous piece)
if (delta.t < piece['time']){
delta.t <- piece['time']
if (delta.t == 0) {
waiting.times <- c(waiting.times, overall.t)                    # wait time 'maxed out', add total waiting time from current time
names(waiting.times)[[length(waiting.times)]] <- compname       # associate waiting times w/ their compartment name
}
# go to next piece and draw new waiting time
} else {
cumul.wait.time <- overall.t - delta.t
waiting.times <- c(waiting.times, cumul.wait.time)                # add the waiting time of current compartment to the vector of waiting times
names(waiting.times)[[length(waiting.times)]] <- compname         # associate the waiting times with their compartments
break
}
}
}
waiting.times
calc.coal.wait.times <- function(model, current.time){
# draw waiting times for all compartments that have two or more extant lineages
# @param model = MODEL object
# @return waiting.times = vector of waiting times
comps <- model$get.compartments()
compnames <- model$get.names(comps)
# retrieves compartments with multiple extant lineages
extant_comps <- unique(sapply(
unname(model$get.pairs()),
function(x) {
comps[[which(compnames == x)]]
}
))
# retrieves compartment names for extant lineages
ext.lineages.compnames <- sapply(
model$get.extant_lineages(current.time),
function(x) {
x$get.location()$get.name()
}
)
# counts the number of extant lineages in one compartment
# calculated for parameter `k` in function `wait.time`
num.ext.lineages <- function(x) {
length(which(ext.lineages.compnames==x))
}
# initialize an empty vector for waiting times
waiting.times <- vector()
for (comp in extant_comps){
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
piece.rows <- which(popn.growth[,'time'] < delta.t)
if (length(piece.rows) == 1) {
pieces <- as.matrix(t(popn.growth[piece.rows, ]))                   # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
rownames(pieces) <- 1
} else {
pieces <- popn.growth[piece.rows, ]
}
for (i in nrow(pieces):1){
# iterate through the valid pieces of population growth dynamics to draw waiting time
# in forward time, start at the current piece first and work backwards to earlier pieces in the popn.growth dynamic fxns (if needed)
piece <- pieces[i,]
wait <- wait.time(num.ext.lineages(compname), piece['intercept'], piece['slope'])
delta.t <- delta.t - wait
# if waiting time exceeds the start time of the piece, move delta.t to the start time (end time of the previous piece)
if (delta.t < piece['time']){
delta.t <- piece['time']
if (delta.t == 0) {
waiting.times <- c(waiting.times, overall.t)                    # wait time 'maxed out', add total waiting time from current time
names(waiting.times)[[length(waiting.times)]] <- compname       # associate waiting times w/ their compartment name
}
# go to next piece and draw new waiting time
} else {
cumul.wait.time <- overall.t - delta.t
waiting.times <- c(waiting.times, cumul.wait.time)                # add the waiting time of current compartment to the vector of waiting times
names(waiting.times)[[length(waiting.times)]] <- compname         # associate the waiting times with their compartments
break
}
}
}
return(waiting.times)
}
coal.wait.times <- calc.coal.wait.times(model, current.time)
coal.wait.times
calc.coal.wait.times(model, current.time)
calc.coal.wait.times(model, current.time)
calc.coal.wait.times(model, current.time)
piece <- pieces[i,]
wait <- wait.time(num.ext.lineages(compname), piece['intercept'], piece['slope'])
wait
compname
num.ext.lineages(compnames)
num.ext.lineages(compname)
piece['intercept']
piece['slope']
alpha <- piece['intercept']
beta <- piece['slope']
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
k <- 3
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
typeof(alpha)
typeof(beta)
alpha/beta
e
u
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
u <- runif(1, 0, 1)
(1-(1-u)^(beta/choose(k,2)))*alpha/beta
piece <- pieces[i,]
wait <- wait.time(num.ext.lineages(compname), piece['intercept'], piece['slope'])
delta.t <- delta.t - wait
delta.t
comps <- model$get.compartments()
compnames <- model$get.names(comps)
extant_comps <- unique(sapply(
unname(model$get.pairs()),
function(x) {
comps[[which(compnames == x)]]
}
))
ext.lineages.compnames <- sapply(
model$get.extant_lineages(current.time),
function(x) {
x$get.location()$get.name()
}
)
num.ext.lineages <- function(x) {
length(which(ext.lineages.compnames==x))
}
waiting.times <- vector()
comp
comp <- extant_comps[[1]]
comp
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
piece.rows <- which(popn.growth[,'time'] < delta.t)
if (length(piece.rows) == 1) {
pieces <- as.matrix(t(popn.growth[piece.rows, ]))                   # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
rownames(pieces) <- 1
} else {
pieces <- popn.growth[piece.rows, ]
}
pieces
nrow(pieces)
i <- 1
piece <- pieces[i,]
piece
piece['intercept']
piece['slope']
wait <- wait.time(num.ext.lineages(compname), piece['intercept'], piece['slope'])
delta.t
wait
current.time
comp$get.branching.time()
delta.t <- delta.t - wait
(delta.t < piece['time'])
delta.t <- piece['time']
delta.t
delta.t == 0
waiting.times <- c(waiting.times, overall.t)                    # wait time 'maxed out', add total waiting time from current time
waiting.times
names(waiting.times)[[length(waiting.times)]] <- compname       # associate waiting times w/ their compartment name
names
waiting.times
e$get.all.events()
comp <- extant_comps[[2]]
compname <- comp$get.name()
popn.growth <- comp$get.type()$get.popn.growth.dynamics()             # retrieve popn.growth.dynamics for this compartment
delta.t = overall.t <- comp$get.branching.time() - current.time       # delta time = compartment infection time - current simulation time
delta.t
piece.rows <- which(popn.growth[,'time'] < delta.t)
if (length(piece.rows) == 1) {
pieces <- as.matrix(t(popn.growth[piece.rows, ]))                   # obtain all the pieces of the popn.growth.dynamics that are valid for current simulation time
rownames(pieces) <- 1
} else {
pieces <- popn.growth[piece.rows, ]
}
pieces
i <- 1
popn.growth
popn.growth <- rbind(popn.growth, c(0,2,NA,NA))
popn.growth
?rbind
popn.growth <- rbind(popn.growth, c(0,2,NA,NA), make.row.names=T)
popn.growth
popn.growth <- rbind(popn.growth, 5=c(0,2,NA,NA))
popn.growth <- rbind(popn.growth, c(0,2,NA,NA))
rownames(popn.growth)
mat <- rbind(mat, c(0,1, NA, NA))
rownames(popn.growth)[[length(rownames(popn.growth))]] <- length(rownames(popn.growth))
mat
length(rownames(popn.growth))
rownames(popn.growth)
mat <- rbind(mat, c(0,1, NA, NA))
rownames(mat)[[length(rownames(mat))]] <- length(rownames(mat))
mat
require(twt)
setwd('~/git/treeswithintrees')
settings <- yaml.load_file('tests/fixtures/example2.yaml')
test <- MODEL$new(settings)
test$get.types()[[1]]$get.popn.growth.dynamics()
require(twt)
setwd('~/git/treeswithintrees')
settings <- yaml.load_file('tests/fixtures/example2.yaml')
test <- MODEL$new(settings)
test$get.types()[[1]]$get.popn.growth.dynamics()
require(twt)
setwd('~/git/treeswithintrees')
settings <- yaml.load_file('tests/fixtures/example2.yaml')
test <- MODEL$new(settings)
test$get.types()[[1]]$get.popn.growth.dynamics()
seq_along(5)
require(twt)
setwd('~/git/treeswithintrees')
settings <- yaml.load_file('tests/fixtures/example2.yaml')
test <- MODEL$new(settings)
test$get.types()[[1]]$get.popn.growth.dynamics()
order(c(0,0,0,1,2,0))
orde(time.bands)
order(time.bands)
time.bands
time.bands[order(time.bands)[2]]
as.numeric(time.bands[order(time.bands)[2]])
