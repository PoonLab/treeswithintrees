storage <- .store.initial.samplings(sources, types, model$get.lineages())
possible.source.types <- storage$s.types
time.bands <- storage$initial.times
# generate transmission events based on population dynamics and Compartments' initial sampling times
t_events <- .calc.transmission.events(popn.totals, popn.rates, time.bands, possible.source.types)
sapply(types, function(x) {
# for each Type, assign transmission times to all infected compartments
r.indices <- which( sapply(sources, function(y) y$get.type()$get.name() == x$get.name()) )
r.comps <- sources[r.indices]
r.init.samplings <- time.bands[ which(names(time.bands) %in% sources.names[r.indices]) ]
r.events <- t_events[ which(t_events$r_type == x$get.name()), ]
if (nrow(r.events) != 0) {            # no transmission events for case of ie. blood compartment
.assign.transmission.times(r.comps, r.events, r.init.samplings, x)
}
})
x <- types[[1]]
r.indices <- which( sapply(sources, function(y) y$get.type()$get.name() == x$get.name()) )
r.comps <- sources[r.indices]
r.init.samplings <- time.bands[ which(names(time.bands) %in% sources.names[r.indices]) ]
r.events <- t_events[ which(t_events$r_type == x$get.name()), ]
nrow(r.events) != 0
x <- types[[2]]
r.indices <- which( sapply(sources, function(y) y$get.type()$get.name() == x$get.name()) )
r.comps <- sources[r.indices]
r.init.samplings <- time.bands[ which(names(time.bands) %in% sources.names[r.indices]) ]
r.events <- t_events[ which(t_events$r_type == x$get.name()), ]
r.events
r.init.samplings
r.comps
r.indices
infected <- r.comps
events <- r.events
initial.samplings <- r.init.samplings
type <- x
type
infected.names <- sapply(infected, function(x) x$get.name())
i.times <- initial.samplings[!is.na(initial.samplings)]                     # separate sampled infected comps from
u.times <- initial.samplings[is.na(initial.samplings)]                      # unsampled infected comps
infected.names
i.times
u.times
length(i.times) > 1
earliest.time <- max(i.times, na.rm=T)                                    # pick Compartment with earliest sampling time (furthest back in time)
recipients.names <- names(i.times)[which(i.times==earliest.time)]         # group all infected with the same sampling time together
recipients.inds <- sapply(recipients.names, function(x) which(infected.names == x))
recipients <- infected[recipients.inds]
recipients
possibleTimes <- events$time[ which(events$r_type == type$get.name()) ]
weights <- sapply(possibleTimes, function(x) eval(parse(text=type$get.wait.time.distr())) )
if (length(possibleTimes) < length(recipients)) {  # for case where one of these recipients will be labeled as the root node (ie. no unsampled hosts)
sampledTimes <- sample(possibleTimes, size=length(recipients)-1, prob=weights, replace=F)
} else {
sampledTimes <- sample(possibleTimes, size=length(recipients), prob=weights, replace=F)
}
possibleTimes
weights
require(twt)
setwd('~/git/treeswithintrees')
source('pkg/R/simOuterTree.R')
file1 <- yaml.load_file('tests/fixtures/example2.yaml')
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
settings <- file2
settings$CompartmentTypes[[1]]$unsampled <- 0
settings$CompartmentTypes[[2]]$unsampled <- 0
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case3 <- sim.outer.tree(model, eventlog)
require(twt)
setwd('~/git/treeswithintrees')
source('pkg/R/simOuterTree.R')
file1 <- yaml.load_file('tests/fixtures/example2.yaml')
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
settings <- file2
settings$CompartmentTypes[[1]]$unsampled <- 0
settings$CompartmentTypes[[2]]$unsampled <- 0
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
model$get.types()[[1]]$get.wait.time.distr()
case3 <- sim.outer.tree(model, eventlog)
comps <- model$get.compartments()
compnames <- model$get.names(comps)
sources <- c(comps, model$get.unsampled.hosts())
sources.names <- model$get.names(sources)
types <- model$get.types()
indiv.types <- sapply(unlist(comps), function(a){a$get.type()$get.name()})
# record population totals and transmission rates for all Types
storage <- .calc.popn.totals.rates(types, indiv.types)
popn.totals <- storage$totals
popn.rates <- storage$rates
# record max sampling times of lineages for each Compartment
storage <- .store.initial.samplings(sources, types, model$get.lineages())
possible.source.types <- storage$s.types
time.bands <- storage$initial.times
# generate transmission events based on population dynamics and Compartments' initial sampling times
t_events <- .calc.transmission.events(popn.totals, popn.rates, time.bands, possible.source.types)
x <- types[[2]]
r.indices <- which( sapply(sources, function(y) y$get.type()$get.name() == x$get.name()) )
r.comps <- sources[r.indices]
r.init.samplings <- time.bands[ which(names(time.bands) %in% sources.names[r.indices]) ]
r.events <- t_events[ which(t_events$r_type == x$get.name()), ]
infected <- r.comps
events <- r.events
initial.samplings <- r.init.samplings
type <- x
infected.names <- sapply(infected, function(x) x$get.name())
i.times <- initial.samplings[!is.na(initial.samplings)]                     # separate sampled infected comps from
u.times <- initial.samplings[is.na(initial.samplings)]                      # unsampled infected comps
earliest.time <- max(i.times, na.rm=T)                                    # pick Compartment with earliest sampling time (furthest back in time)
recipients.names <- names(i.times)[which(i.times==earliest.time)]         # group all infected with the same sampling time together
recipients.inds <- sapply(recipients.names, function(x) which(infected.names == x))
recipients <- infected[recipients.inds]
possibleTimes <- events$time[ which(events$r_type == type$get.name()) ]
weights <- sapply(possibleTimes, function(x) eval(parse(text=type$get.wait.time.distr())) )
type$get.wait.time.distr()
require(twt)
setwd('~/git/treeswithintrees')
source('pkg/R/simOuterTree.R')
file1 <- yaml.load_file('tests/fixtures/example2.yaml')
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
settings <- file2
settings$CompartmentTypes[[1]]$unsampled <- 0
settings$CompartmentTypes[[2]]$unsampled <- 0
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case3 <- sim.outer.tree(model, eventlog)
comps <- model$get.compartments()
compnames <- model$get.names(comps)
sources <- c(comps, model$get.unsampled.hosts())
sources.names <- model$get.names(sources)
types <- model$get.types()
indiv.types <- sapply(unlist(comps), function(a){a$get.type()$get.name()})
# record population totals and transmission rates for all Types
storage <- .calc.popn.totals.rates(types, indiv.types)
popn.totals <- storage$totals
popn.rates <- storage$rates
# record max sampling times of lineages for each Compartment
storage <- .store.initial.samplings(sources, types, model$get.lineages())
possible.source.types <- storage$s.types
time.bands <- storage$initial.times
# generate transmission events based on population dynamics and Compartments' initial sampling times
t_events <- .calc.transmission.events(popn.totals, popn.rates, time.bands, possible.source.types)
x <- types[[2]]
r.indices <- which( sapply(sources, function(y) y$get.type()$get.name() == x$get.name()) )
r.comps <- sources[r.indices]
r.init.samplings <- time.bands[ which(names(time.bands) %in% sources.names[r.indices]) ]
r.events <- t_events[ which(t_events$r_type == x$get.name()), ]
infected <- r.comps
events <- r.events
initial.samplings <- r.init.samplings
type <- x
type
infected.names <- sapply(infected, function(x) x$get.name())
i.times <- initial.samplings[!is.na(initial.samplings)]                     # separate sampled infected comps from
u.times <- initial.samplings[is.na(initial.samplings)]                      # unsampled infected comps
earliest.time <- max(i.times, na.rm=T)                                    # pick Compartment with earliest sampling time (furthest back in time)
recipients.names <- names(i.times)[which(i.times==earliest.time)]         # group all infected with the same sampling time together
recipients.inds <- sapply(recipients.names, function(x) which(infected.names == x))
recipients <- infected[recipients.inds]
possibleTimes <- events$time[ which(events$r_type == type$get.name()) ]
weights <- sapply(possibleTimes, function(x) eval(parse(text=type$get.wait.time.distr())) )
if (length(possibleTimes) < length(recipients)) {  # for case where one of these recipients will be labeled as the root node (ie. no unsampled hosts)
sampledTimes <- sample(possibleTimes, size=length(recipients)-1, prob=weights, replace=F)
} else {
sampledTimes <- sample(possibleTimes, size=length(recipients), prob=weights, replace=F)
}
sampledTimes
for (x in 1:length(sampledTimes)) {
# now assign `sampledTimes` to `recipients`, uniformly distributed
ind <- sample.int(length(recipients), 1)
t.time <- sampledTimes[x]
recipients[[ind]]$set.branching.time(t.time)
recipients <- recipients[-ind]
events <- events[ -which(events$time == t.time), ]                     # remove transmission event from events
}
if (length(recipients) != 0) sapply(recipients, function(x) x$set.branching.time(NA))
i.times <- i.times[ -which(i.times==earliest.time) ]
i.times
comps
head(comps)
require(twt)
setwd('~/git/treeswithintrees')
source('pkg/R/simOuterTree.R')
file1 <- yaml.load_file('tests/fixtures/example2.yaml')
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
settings <- file2
settings$CompartmentTypes[[1]]$unsampled <- 0
settings$CompartmentTypes[[2]]$unsampled <- 0
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case3 <- sim.outer.tree(model, eventlog)
case3$get.all.events()
settings <- file2
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case4 <- sim.outer.tree(model, eventlog)
case4$get.all.events()
settings <- file2
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case4 <- sim.outer.tree(model, eventlog)
case4$get.all.events()
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
settings <- file2
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case4 <- sim.outer.tree(model, eventlog)
case4$get.all.events()
?proc.time
require(twt)
setwd('~/git/treeswithintrees')
source('pkg/R/simOuterTree.R')
file1 <- yaml.load_file('tests/fixtures/example2.yaml')
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
settings <- file1
settings$CompartmentTypes[[1]]$unsampled <- 0
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case1 <- sim.outer.tree(model, eventlog)
comps <- model$get.compartments()
compnames <- model$get.names(comps)
sources <- c(comps, model$get.unsampled.hosts())
sources.names <- model$get.names(sources)
types <- model$get.types()
indiv.types <- sapply(unlist(comps), function(a){a$get.type()$get.name()})
storage <- .calc.popn.totals.rates(types, indiv.types)
popn.totals <- storage$totals
popn.rates <- storage$rates
storage <- .store.initial.samplings(sources, types, model$get.lineages())
possible.source.types <- storage$s.types
time.bands <- storage$initial.times
t_events <- .calc.transmission.events(popn.totals, popn.rates, time.bands, possible.source.types)
sapply(types, function(x) {
# for each Type, assign transmission times to all infected compartments
r.indices <- which( sapply(sources, function(y) y$get.type()$get.name() == x$get.name()) )
r.comps <- sources[r.indices]
r.init.samplings <- time.bands[ which(names(time.bands) %in% sources.names[r.indices]) ]
r.events <- t_events[ which(t_events$r_type == x$get.name()), ]
if (nrow(r.events) != 0) {            # no transmission events for case of ie. blood compartment
.assign.transmission.times(r.comps, r.events, r.init.samplings, x)
} else {
sapply(r.comps, function(x) x$set.branching.time(NA))
}
})
mark1 <- proc.time() - ptm            # benchmark 1 (generation of transmission events)
comps <- comps[ order(sapply(comps, function(x) x$get.branching.time())) ]
source.popns = source.popns.names <- setNames(vector(length(types), mode="list"), names(types))
for (x in 1:length(names(source.popns))) {
specific.type <- names(source.popns)[x]
s.pop.by.type <- sapply(sources, function(y) {
if (y$get.type()$get.name() == specific.type) {
if (is.na(y$get.branching.time())) {y}    # root no branching time
else if (y$get.branching.time() > comps[[1]]$get.branching.time()) {y}
}
})
s.pop.by.type[sapply(s.pop.by.type, is.null)] <- NULL    # cleanup
s.pop.by.type.names <- sapply(s.pop.by.type, function(z) z$get.name())
source.popns[[specific.type]] <- s.pop.by.type
source.popns.names[[specific.type]] <- s.pop.by.type.names
}
numActive <- length(comps)
while (numActive > 1) {
r_ind_comps <- 1                            # first recipient == most recent infection time == largest list of `sources` --> efficiency
recipient <- comps[[r_ind_comps]]
r_name <- recipient$get.name()
r_type <- recipient$get.type()$get.name()
# remove chosen recipient from relevant lists (`comps` and possibly `source.popns`)
comps[[ r_ind_comps ]] <- NULL
compnames <- compnames[-r_ind_comps]
ind_source_popn <- which(source.popns.names[[r_type]] == r_name)
if (length(ind_source_popn) != 0) {         # TRUE for all iterations except initial iteration case (bc starting recipient already removed)
source.popns[[r_type]][[ind_source_popn]] <- NULL
source.popns.names[[r_type]] <- source.popns.names[[r_type]][-ind_source_popn]
}
# list of possible sources is based off of the `s_type` recorded in the event associated with the transmission time in master copy `t_events`
if (is.na(recipient$get.branching.time())) {
# root case, "final" resolved transmission event (aka first recorded transmission, furthest back in time)
s_name <- NA
eventlog$add.event('transmission', recipient$get.branching.time(),NA, NA, r_name, s_name)
break
} else {
s_type <- t_events[ which(t_events$time == recipient$get.branching.time()), 's_type']
list.sources <- source.popns.names[[s_type]]
# select source from a list of sources previously separated by Type
s_ind_s_popn <- sample.int(length(list.sources), 1)
s_name <- list.sources[s_ind_s_popn]
source <- source.popns[[s_type]][[s_ind_s_popn]]
eventlog$add.event('transmission', recipient$get.branching.time(),NA, NA, r_name, s_name)
}
# if source is an unsampled infected Compartment, now holds a sampled lineage we care about (promote us_comp)
if (source$is.unsampled()) {
# add us_comp to list `comps` (once first a source, can now be a recipient)
comps[[length(comps)+1]] <- source
compnames[[length(compnames)+1]] <- s_name
}
# update recipient object `source` attr
recipient$set.source(source)
# update number of active compartments (excludes recipients, includes promoted us_comps)
comps <- comps[ order(sapply(comps, function(x) x$get.branching.time())) ]
numActive <- length(comps)
}
require(twt)
setwd('~/git/treeswithintrees')
source('pkg/R/simOuterTree.R')
file1 <- yaml.load_file('tests/fixtures/example2.yaml')
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
settings <- file1
settings$CompartmentTypes[[1]]$unsampled <- 0
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
ptm <- proc.time()   # benchmark start time
comps <- model$get.compartments()
compnames <- model$get.names(comps)
sources <- c(comps, model$get.unsampled.hosts())
sources.names <- model$get.names(sources)
types <- model$get.types()
indiv.types <- sapply(unlist(comps), function(a){a$get.type()$get.name()})
# record population totals and transmission rates for all Types
storage <- .calc.popn.totals.rates(types, indiv.types)
popn.totals <- storage$totals
popn.rates <- storage$rates
# record max sampling times of lineages for each Compartment
storage <- .store.initial.samplings(sources, types, model$get.lineages())
possible.source.types <- storage$s.types
time.bands <- storage$initial.times
# generate transmission events based on population dynamics and Compartments' initial sampling times
t_events <- .calc.transmission.events(popn.totals, popn.rates, time.bands, possible.source.types)
sapply(types, function(x) {
# for each Type, assign transmission times to all infected compartments
r.indices <- which( sapply(sources, function(y) y$get.type()$get.name() == x$get.name()) )
r.comps <- sources[r.indices]
r.init.samplings <- time.bands[ which(names(time.bands) %in% sources.names[r.indices]) ]
r.events <- t_events[ which(t_events$r_type == x$get.name()), ]
if (nrow(r.events) != 0) {            # no transmission events for case of ie. blood compartment
.assign.transmission.times(r.comps, r.events, r.init.samplings, x)
} else {
sapply(r.comps, function(x) x$set.branching.time(NA))
}
})
mark1 <- proc.time() - ptm            # benchmark 1 (generation of transmission events)
# after transmission times are matched with infected Compartments as recipients, now have to assign source Compartments
# order infection times from most recent to furthest back in time
comps <- comps[ order(sapply(comps, function(x) x$get.branching.time())) ]
# each assigned transmission time is associated with an event, which determines what TYPE its source is, just not which Compartment in particular
source.popns = source.popns.names <- setNames(vector(length(types), mode="list"), names(types))
# separate source populations into lists that are as many as the number of distinct Types in the model
for (x in 1:length(names(source.popns))) {
specific.type <- names(source.popns)[x]
s.pop.by.type <- sapply(sources, function(y) {
if (y$get.type()$get.name() == specific.type) {
if (is.na(y$get.branching.time())) {y}    # root no branching time
else if (y$get.branching.time() > comps[[1]]$get.branching.time()) {y}
}
})
s.pop.by.type[sapply(s.pop.by.type, is.null)] <- NULL    # cleanup
s.pop.by.type.names <- sapply(s.pop.by.type, function(z) z$get.name())
source.popns[[specific.type]] <- s.pop.by.type
source.popns.names[[specific.type]] <- s.pop.by.type.names
}
# assign source compartments for all sampled infected and promoted unsampled infected Compartments
numActive <- length(comps)
while (numActive > 1) {
r_ind_comps <- 1                            # first recipient == most recent infection time == largest list of `sources` --> efficiency
recipient <- comps[[r_ind_comps]]
r_name <- recipient$get.name()
r_type <- recipient$get.type()$get.name()
# remove chosen recipient from relevant lists (`comps` and possibly `source.popns`)
comps[[ r_ind_comps ]] <- NULL
compnames <- compnames[-r_ind_comps]
ind_source_popn <- which(source.popns.names[[r_type]] == r_name)
if (length(ind_source_popn) != 0) {         # TRUE for all iterations except initial iteration case (bc starting recipient already removed)
source.popns[[r_type]][[ind_source_popn]] <- NULL
source.popns.names[[r_type]] <- source.popns.names[[r_type]][-ind_source_popn]
}
# list of possible sources is based off of the `s_type` recorded in the event associated with the transmission time in master copy `t_events`
if (is.na(recipient$get.branching.time())) {
# root case, "final" resolved transmission event (aka first recorded transmission, furthest back in time)
s_name <- NA
eventlog$add.event('transmission', recipient$get.branching.time(),NA, NA, r_name, s_name)
break
} else {
s_type <- t_events[ which(t_events$time == recipient$get.branching.time()), 's_type']
list.sources <- source.popns.names[[s_type]]
# select source from a list of sources previously separated by Type
s_ind_s_popn <- sample.int(length(list.sources), 1)
s_name <- list.sources[s_ind_s_popn]
source <- source.popns[[s_type]][[s_ind_s_popn]]
eventlog$add.event('transmission', recipient$get.branching.time(),NA, NA, r_name, s_name)
}
# if source is an unsampled infected Compartment, now holds a sampled lineage we care about (promote us_comp)
if (source$is.unsampled()) {
# add us_comp to list `comps` (once first a source, can now be a recipient)
comps[[length(comps)+1]] <- source
compnames[[length(compnames)+1]] <- s_name
}
# update recipient object `source` attr
recipient$set.source(source)
# update number of active compartments (excludes recipients, includes promoted us_comps)
comps <- comps[ order(sapply(comps, function(x) x$get.branching.time())) ]
numActive <- length(comps)
}
mark2 <- proc.time() - mark1               # benchmark 2 (assignment of sources)
eventlog
require(twt)
setwd('~/git/treeswithintrees')
source('pkg/R/simOuterTree.R')
file1 <- yaml.load_file('tests/fixtures/example2.yaml')
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
# Case 1: single Type, multiple sampled infected, no unsampled infected
settings <- file1
settings$CompartmentTypes[[1]]$unsampled <- 0
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case1 <- sim.outer.tree(model, eventlog)
model$get.types()
require(twt)
setwd('~/git/treeswithintrees')
source('pkg/R/simOuterTree.R')
file1 <- yaml.load_file('tests/fixtures/example2.yaml')
file2 <- yaml.load_file('tests/fixtures/example3.yaml')
settings <- file1
model <- MODEL$new(settings)
eventlog <- EventLogger$new()
case2 <- sim.outer.tree(model, eventlog)
ptm <- proc.time()   # benchmark start time
comps <- model$get.compartments()
compnames <- model$get.names(comps)
sources <- c(comps, model$get.unsampled.hosts())
sources.names <- model$get.names(sources)
types <- model$get.types()
indiv.types <- sapply(unlist(comps), function(a){a$get.type()$get.name()})
types
storage <- .calc.popn.totals.rates(types, indiv.types)
popn.totals <- storage$totals
popn.rates <- storage$rates
storage <- .store.initial.samplings(sources, types, model$get.lineages())
possible.source.types <- storage$s.types
time.bands <- storage$initial.times
t_events <- .calc.transmission.events(popn.totals, popn.rates, time.bands, possible.source.types)
sapply(types, function(x) {
# for each Type, assign transmission times to all infected compartments
r.indices <- which( sapply(sources, function(y) y$get.type()$get.name() == x$get.name()) )
r.comps <- sources[r.indices]
r.init.samplings <- time.bands[ which(names(time.bands) %in% sources.names[r.indices]) ]
r.events <- t_events[ which(t_events$r_type == x$get.name()), ]
if (nrow(r.events) != 0) {            # no transmission events for case of ie. blood compartment
.assign.transmission.times(r.comps, r.events, r.init.samplings, x)
} else {
sapply(r.comps, function(x) x$set.branching.time(NA))
}
})
types
comps
mark1 <- proc.time() - ptm            # benchmark 1 (generation of transmission events)
comps <- comps[ order(sapply(comps, function(x) x$get.branching.time())) ]
source.popns = source.popns.names <- setNames(vector(length(types), mode="list"), names(types))
for (x in 1:length(names(source.popns))) {
specific.type <- names(source.popns)[x]
s.pop.by.type <- sapply(sources, function(y) {
if (y$get.type()$get.name() == specific.type) {
if (is.na(y$get.branching.time())) {y}    # root no branching time
else if (y$get.branching.time() > comps[[1]]$get.branching.time()) {y}
}
})
s.pop.by.type[sapply(s.pop.by.type, is.null)] <- NULL    # cleanup
s.pop.by.type.names <- sapply(s.pop.by.type, function(z) z$get.name())
source.popns[[specific.type]] <- s.pop.by.type
source.popns.names[[specific.type]] <- s.pop.by.type.names
}
numActive <- length(comps)
while (numActive > 1) {
r_ind_comps <- 1                            # first recipient == most recent infection time == largest list of `sources` --> efficiency
recipient <- comps[[r_ind_comps]]
r_name <- recipient$get.name()
r_type <- recipient$get.type()$get.name()
# remove chosen recipient from relevant lists (`comps` and possibly `source.popns`)
comps[[ r_ind_comps ]] <- NULL
compnames <- compnames[-r_ind_comps]
ind_source_popn <- which(source.popns.names[[r_type]] == r_name)
if (length(ind_source_popn) != 0) {         # TRUE for all iterations except initial iteration case (bc starting recipient already removed)
source.popns[[r_type]][[ind_source_popn]] <- NULL
source.popns.names[[r_type]] <- source.popns.names[[r_type]][-ind_source_popn]
}
# list of possible sources is based off of the `s_type` recorded in the event associated with the transmission time in master copy `t_events`
if (is.na(recipient$get.branching.time())) {
# root case, "final" resolved transmission event (aka first recorded transmission, furthest back in time)
s_name <- NA
eventlog$add.event('transmission', recipient$get.branching.time(),NA, NA, r_name, s_name)
break
} else {
s_type <- t_events[ which(t_events$time == recipient$get.branching.time()), 's_type']
list.sources <- source.popns.names[[s_type]]
# select source from a list of sources previously separated by Type
s_ind_s_popn <- sample.int(length(list.sources), 1)
s_name <- list.sources[s_ind_s_popn]
source <- source.popns[[s_type]][[s_ind_s_popn]]
eventlog$add.event('transmission', recipient$get.branching.time(),NA, NA, r_name, s_name)
}
# if source is an unsampled infected Compartment, now holds a sampled lineage we care about (promote us_comp)
if (source$is.unsampled()) {
# add us_comp to list `comps` (once first a source, can now be a recipient)
comps[[length(comps)+1]] <- source
compnames[[length(compnames)+1]] <- s_name
}
# update recipient object `source` attr
recipient$set.source(source)
# update number of active compartments (excludes recipients, includes promoted us_comps)
comps <- comps[ order(sapply(comps, function(x) x$get.branching.time())) ]
numActive <- length(comps)
}
mark2 <- proc.time() - mark1               # benchmark 2 (assignment of sources)
eventlog
eventlog$get.all.events()
