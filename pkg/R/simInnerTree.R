#' sim.inner.tree
#' 
#' Simulate the coalescence of pathogen lineages within hosts (compartments)
#' AND resolve the migration events that may or may not involve sampled pathogen 
#' lineages within hosts.
#'
#' @param mod: R6 Model or Run object.  If user provides a Model object, then an 
#'        EventLogger object, such as generated by eventlog.from.tree(), must also 
#'        be provided.
#' @param e: (optional) R6 EventLogger object
#' @return EventLogger object updated with inner tree events.
#' 
#' @examples
#' # load model
#' path <- system.file('extdata', 'SI.yaml', package='twt')
#' 
#' # load file and parse to construct MODEL object
#' settings <- yaml.load_file(path)
#' mod <- Model$new(settings)
#' 
#' # simulate outer tree - returns a Run object carrying EventLogger
#' run <- sim.outer.tree(mod)
#' 
#' # simulate inner tree
#' tree <- sim.inner.tree(run)
#' plot(tree)
#' 
#' @export
sim.inner.tree <- function(mod, e=NA) {
  if ( is.element('Run', class(mod)) ) {
    run <- mod
    if ( nrow(run$get.eventlog()$get.all.events()) ==0 ) {
      stop("Error in sim.inner.tree(): empty EventLogger in Run object. ",
           "Did you run sim.outer.tree() before calling this function?")
    }
  }
  else if ( is.element('Model', class(mod)) ) {
    # in one use case, the user manually specifies the outer tree 
    # as an EventLogger object, but we still need a Model object to 
    # parameterize the inner tree simulation
    if (is.environment(e)) {
      run <- Run$new(mod)
      # don't modify the original EventLogger object
      run$set.eventlog(e$clone())
      eventlog <- run$get.eventlog()
    } 
    else {
      stop("You must provide an EventLogger to sim.inner.tree() if `mod` is a Model object")
    }
  }
  else {
    stop("sim.inner.tree(): argument `mod` must be R6 class Model or Run.")
  }
  
  eventlog <- run$get.eventlog()
  
  
  # vector of all infected Compartments in population at time zero (most recent)
  inf <- c(run$get.compartments(), run$get.unsampled.hosts())
  
  # retrieve transmission events and times
  transm.events <- eventlog$get.events('transmission')
  transm.times <- transm.events$time[!is.na(transm.events$time)]
  
  # check that compartment names in transmission events match model
  transm.names <- unique(c(transm.events$compartment1, transm.events$compartment2))
  if ( !all(is.element(transm.names, names(inf))) ) {
    missing <- setdiff(transm.names, names(inf))
    stop("Mismatch between compartment names in transmission events and Compartment ",
         "names in Run object: ", missing)
  }
  
  # retrieve migration events **to be resolved** and times
  migration.events <- eventlog$get.migration.events()
  migration.times <- migration.events$time
  
  # intitialize simulation at time of most recently sampled Lineage
  current.time <- 0.0
  
  # collect extant lineages at time t=0 and store into a vector
  extant.lineages <- run$get.extant.lineages(current.time)
  num.extant <- length(extant.lineages)
  if (num.extant == 0) {
    stop ('There must be at least one lineage sampled at time t=0.')
  }
  
  
  while (num.extant >= 1) {
    
    # issue 54, case where there is 1 extant lineage remaining, but final 
    # transmission event further back in time still unresolved
    if (num.extant == 1) {
      
      # check if any of the transmission events are still left unresolved
      t_events <- eventlog$get.events('transmission')
      unresolved <- is.na(t_events$lineage1)
      
      if ( any(unresolved) ) {
        final.t.time <- t_events[which(unresolved), 'time']
        last.lineage <- extant.lineages[[1]]$get.name()
        eventlog$modify.event(final.t.time, last.lineage)
      }
      
      break
    }
    
    # calculate waiting times for coalescent events for each compartment 
    # with 2 or more lineages
    coal.wait.times <- calc.coal.wait.times(run, current.time)
    
    # record number of transmission events already included in simulation at 
    # this current.time
    num.transm.occurred <- sum(transm.times <= current.time)
    
    # record number of migration events already included in simulation at this 
    # current.time
    num.migrations.occurred <- sum(migration.times <= current.time)
      
    if (length(coal.wait.times) == 0) {
      # no coalescent events possible at this point in time (all Compartments carry 
      # no more than one Lineage)
      # move up to the next transmission or migration event in the EventLogger
      
      # minimum time to next transmission event
      current.time <- min(transm.times[which(transm.times > current.time)])
      is.transmission.next <- TRUE
      if (!is.null(migration.times)) {
        # minimum time to next migration event
        migration.time <- min(migration.times[which(migration.times > current.time)])
        if (migration.time < current.time) {
          is.transmission.next <- FALSE
          current.time <- migration.time
        }
        else if (migration.time == current.time) {
          # handle edge case where migration and transmission events occur
          # at same instant
          is.transmission.next <- sample(c(TRUE, FALSE), 1)
          current.time <- ifelse(is.transmission.next, current.time, migration.time)
        }
      }
      
      
      # must resolve transmission event or migration event (issue #53)
      if (is.transmission.next) {
        # transmission event to be resolved
        transm.event <- transm.events[which(transm.times == current.time),]
        update.transmission(run, inf, transm.event)
      } 
      else {
        # migration event to be resolved
        migration.event <- migration.events[which(migration.times == current.time),]
        resolve.migration(run, inf, migration.event)
      }
      
      extant.lineages <- run$get.extant.lineages(current.time)
      num.extant <- length(extant.lineages)
      
      next  # go to next iteration
    } 
    
    
    # get waiting time to next coalescent event and evaluate this time interval
    wait.time.to.next.coal <- min(coal.wait.times)
    new.time <- current.time + wait.time.to.next.coal
    
    
    # check to see if the minimum waiting time is not exceeded by other fixed events:
    skipped.transm.times <- transm.times[which(
      (transm.times > current.time) && (transm.times <= new.time)
      )]
    
    if ( length(skipped.transm.times) > 0 ) {
      # if minimum waiting time to coalescent exceeds a transmission event not 
      # previously included in sim, update the current time to the earlier 
      # transmission time of all newly included transmission events and start again
      current.time <- min(skipped.transm.times) 
      
      
      transm.event <- transm.events[which(transm.times == current.time),]
      update.transmission(run, inf, transm.event)
      
      extant.lineages <- run$get.extant.lineages(current.time)
      num.extant <- length(extant.lineages)
      
      next
      
    } else if (length(which(migration.times <= new.time)) > num.migrations.occurred) {
      # next event is a migration event that needs to be resolved      
      
      old.migrations <- migration.times[which(migration.times <= current.time)]
      all.new.migrations <- migration.times[which(migration.times <= new.time)]
      current.time <- min(setdiff(all.new.migrations, old.migrations))
      
      migration.event <- migration.events[which(migration.times == current.time),]
      resolve.migration(run, inf, migration.event)
      
      # TODO : maybe don't "restart" this simulation, rather, go straight to the next checks
      current.time <- new.time
      extant.lineages <- run$get.extant.lineages(current.time)
      num.extant <- length(extant.lineages)
      
      next
      
    } else if (length(run$get.extant.lineages(new.time)) > num.extant) {
      # OR other lineage(s) become(s) extant before the waiting time
      # update the current time to add the waiting time and start again
      
      current.time <- new.time
      extant.lineages <- run$get.extant.lineages(current.time)
      num.extant <- length(extant.lineages)
      
      next
      
    } else {
      # checks have been made, move forward with generating a coalescent event with the new time
      
      # choose a 'bin' from compartment with new.time
      # name of the compartment with the min coal wait time
      coal.comp.name <- names(coal.wait.times)[which(coal.wait.times == wait.time.to.next.coal)]   
      
      coal.comp <- inf[[which(names(inf) == coal.comp.name)]]
      
      coal.comp.lineages <- sapply(extant.lineages, function(x){
        if (x$get.location()$get.name() == coal.comp.name) {x}
        else {NULL}
      })
      
      coal.comp.lineages[sapply(coal.comp.lineages, is.null)] <- NULL   # cleanup
      lineages.to.coalesce <- sample(coal.comp.lineages, 2)
      generate.coalescent(run, eventlog, lineages.to.coalesce, coal.comp, new.time)
      

      if (length(which(transm.times <= new.time)) > num.transm.occurred) {
        # issue 40: if coalescent event occurs at a transmission time, force coalescence of all other lineages at this time
        
        old.transm <- transm.times[which(transm.times <= current.time)]
        all.new.transm <- which(transm.times <= new.time)
        current.time <- min(union( all.new.transm, old.transm ))
        
        # this is new.time instead of current.time (compared to the outermost if statement)
        transm.event <- transm.events[which(transm.times == new.time),]     
        update.transmission(run, inf, transm.event)
        
      }
      
      # update current time and extant lineages
      current.time <- new.time
      extant.lineages <- run$get.extant.lineages(current.time)
      num.extant <- length(extant.lineages)
      
    }
    
  }
  
  return(run)  # contains updated eventlog 
}


#' update.transmission
#' 
#' \code{update.transmission} resolves lineages associated with a transmission event 
#' between compartments and updates the eventlog.
#'
#' @param run: Run object
#' @param inf: list of sampled and unsampled infected compartments of type Compartment
#' @param transm.event: list of information specific to the transmission event being resolved
#' 
#' @export update.transmission
update.transmission <- function(run, inf, transm.event) {

  # retrieve Compartment objects
  recipient <- inf[[ transm.event$compartment1 ]]
  if (is.null(recipient)) {
    stop("update.transmission() failed to locate recipient Compartment ",
         transm.event$compartment2)
  }

  source <- inf[[ transm.event$compartment2 ]]
  if (is.null(source)) {
    stop("update.transmission() failed to locate source Compartment ", 
         transm.event$compartment1)
  }

  # apply bottleneck in recipient
  survivor.lineages <- generate.bottleneck(run, recipient)
  name.str <- c()
  for (lineage in survivor.lineages) {
    # move "surviving" Lineages to source Compartment
    recipient$remove.lineage(lineage)
    lineage$set.location(source)
    source$add.lineage(lineage)
    
    name.str <- c(name.str, lineage$get.name())
  }
  
  eventlog <- run$get.eventlog()
  eventlog$modify.event(transm.event$time, paste0(name.str, collapse=','))
}


#' resolve.migration
#' 
#' function resolves a potential migration event generated from 
#' `sim.migrations()`
#'
#' @param run: Run object
#' @param inf: list of sampled and unsampled infected compartments 
#'        of type Compartment
#' @param migration.event: list of information specific to the migration 
#'        event being resolved
#' 
#' @export
resolve.migration <- function(run, inf, migration.event) {
  
  # first, draw a random recipient compartment with a matching recipientType 
  # of the migration event to be resolved
  possible.recipients <- sapply(inf, function(x) {
    if (x$get.type()$get.name() == migration.event$r_type) {x}
  })
  possible.recipients[sapply(possible.recipients, is.null)] <- NULL
  chosen.recipient <- sample(possible.recipients, 1)[[1]]
  
  # does this compartment involve one of our sampled infected compartments?
  if ( !chosen.recipient$is.unsampled() ) {
    
    # if so, does this migration event involve one of our sampled lineages?
    # probability of the migration involving a sampled lineage is (number of 
    # extant sampled lineages / N ), where N = 1/coal.rate
    prob.samp.lin <- length(chosen.recipient$get.lineages()) * 
      chosen.recipient$get.type()$get.coalescent.rate()
    
    # if so, draw a source compartment with a matching sourceType to the event to be resolved
    # additionally, randomly draw a sampled infected lineage to be the migrating lineage 
    # and generate the migration event
    if (runif(1) < prob.samp.lin) {
      
      possible.sources <- sapply(inf, function(y) {
        if (y$get.type()$get.name() == migration.event$s_type) {y}
      })
      possible.sources[sapply(possible.sources, is.null)] <- NULL   # cleanup
      chosen.source <- sample(possible.sources, 1)[[1]]

      # draw a lineage to be migrated
      migrating.lineage <- sample(chosen.recipient$get.lineages(), 1)[[1]]
      generate.migration(run, chosen.source, chosen.recipient, 
                         migrating.lineage, migration.event$time)
    }
    
  }
  
}


#' generate.migration
#' 
#' Function to record a migration event of a given Lineage from a source to 
#' recipient compartment.
#'
#' @param run: Run object
#' @param migrating.lineage: Lineage object; to be migrated
#' @param inf: list of Compartment objects as potential migration sources
#' @param current.time: double; time of simulation current to this function call
#' 
#' @export
generate.migration <- function(run, source, recipient, migrating.lineage, 
                               migration.time) {

  if ( !identical(migrating.lineage$get.location(), recipient) ) {
    stop("Error in generate.migration: Lineage ", migrating.lineage.$get.name(),
         " is not located in Compartment ", recipient$get.name())
  }
  l_name <- migrating.lineage$get.name()  # lineage name

  eventlog <- run$get.eventlog()  
  outer.tree.events <- eventlog$get.events('transmission')
  outer.tree.comps <- union(outer.tree.events$compartment1, 
                            outer.tree.events$compartment2)

  if ( !is.element(source$get.name(), outer.tree.comps) ) {
    # issue #32: if migration of lineages from unsampled (US) individual not 
    # already included in outer tree (via transmission event), have to graft 
    # another branch to the outer tree.
    # 
    # Source of migration is from US individual not already included in outer 
    # tree --> sample a transmission time from stored vector of used & unused 
    # times.
    
    t.times <- source$get.type()$get.transmission.times()
    print(t.times)
    index <- which(t.times[names(t.times)==T] >= migration.time)
    if (length(index) == 0) {
      stop("Error in generate.migration(): CompartmentType ", source$get.type()$get.name(),
           " has no unused transmission times >= migration time ", migration.time)
    }

    # sample an available time
    avail.t.time <- t.times[ sample(index, 1) ]

    # reset the vector to make the sampled time now unavailable
    # CONFIRMED: the type's vector of available t.times is updated for every 
    # compartment under this Compartment Type
    sampled.t.time.ind <- which(t.times == avail.t.time)
    names(t.times)[sampled.t.time.ind] <- FALSE
    
    types <- run$get.types()
    master.comp.type <- which( names(types) == source$get.type()$get.name() )
    types[[master.comp.type]]$set.transmission.times(t.times)

    # generate new transmission event for branch to be grafted onto tree
    eventlog$add.event('transmission', avail.t.time, l_name, NA, 
                       recipient$get.name(), source$get.name())
  }

  # add lineage to source compartment
  source$add.lineage(migrating.lineage)
  add.lineage.pairs(run, migrating.lineage)

  # remove lineage from recipient compartment
  recipient$remove.lineage(migrating.lineage)
  remove.lineage.pairs(run, migrating.lineage)

  # set location of migrating lineage to source compartment
  migrating.lineage$set.location(source)

  # add migration event to EventLogger
  eventlog$add.event('migration', migration.time, l_name, NA, 
                     recipient$get.name(), source$get.name())

}


#' generate.coalescent
#' 
#' function records the coalescent of 2 given lineages currently extant in given 
#' Compartment into an ancestral lineage
#'
#' @param run:  R6 Run object
#' @param line1:  Lineage object
#' @param line2:  Lineage object
#' @param comp:  Compartment object
#' @param current.time:  double; time of simulation current to this function call
#' 
#' @return R6 Compartment object updated by coalescent event
#' 
#' @export
generate.coalescent <- function(run, line1, line2, current.time, is.bottleneck=FALSE) {
  comp <- line1$get.location()
  if (comp$get.name() != line2$get.location()$get.name()) {
    stop("Error in generate.coalescent: lineages must be in the same Compartment.")
  }
  
  # create a new ancestral lineage 
  ancestral.lineage <- Lineage$new(
    name = run$get.node.ident(),  # label internal nodes from 1..inf by convention
    sampling.time = current.time,
    location = comp
    )
  
  # remove lineages undergoing coalescence
  run$remove.lineage(line1)
  run$remove.lineage(line2)
  
  # add ancestral lineage resulting from coalescence
  run$add.lineage(ancestral.lineage)
  
  # remove pairs containing coalesced lineages from list of pair choices
  . <- remove.lineage.pairs(run, line1)
  . <- remove.lineage.pairs(run, line2)
  
  # add pairs with new ancestral lineage into list of pair choices
  . <- add.lineage.pairs(run, ancestral.lineage)
  
  
  # update event log
  eventlog <- run$get.eventlog()
  
  eventlog$add.event(type = ifelse(is.bottleneck, 'bottleneck', 'coalescent'), 
                     time = current.time, line1 = line1$get.name(), 
                     line2 = ancestral.lineage$get.name(), comp1 = comp$get.name())
  
  eventlog$add.event(type = ifelse(is.bottleneck, 'bottleneck', 'coalescent'), 
                     time = current.time, line1 = line2$get.name(), 
                     line2 = ancestral.lineage$get.name(), comp1 = comp$get.name())
  
  return(comp)
}


#' generate.bottleneck
#' 
#' function coalesces lineages currently extant in given Compartment to the given 
#' Compartment's bottleneck size bottleneck size of Compartment is user determined 
#' by CompartmentType
#'
#' @param run = R6 Run object
#' @param comp = Compartment object
#' 
#' @return  lineages that 'survive' the bottleneck on towards source of transmission 
#' in coalescent time
#' 
#' @export
generate.bottleneck <- function(run, comp) {
  
  current.time <- comp$get.branching.time()
  if (!is.numeric(current.time)) {
    stop("Error in generate.bottleneck: Compartment ", comp$get.name(), 
         " has no assigned branching time.")
  }
  
  bottleneck.size <- comp$get.type()$get.bottleneck.size()
  if (!is.numeric(bottleneck.size)) {
    stop("Error in generate.bottleneck: Compartment ", comp$get.name(),
         " has no bottleneck size specified.")
  }
  
  # randomly separate lineages into "bottleneck groups", equal number of groups to 
  # the bottleneck size  
  lineages <- comp$get.lineages()
  if (length(lineages) == 0) {
    stop("Error in generate.bottleneck: Compartment ", comp$get.name(),
         " has no Lineages to bottleneck!")
  }
  
  
  while (length(lineages) > bottleneck.size) {
    pair <- sample(lineages, 2, replace=FALSE)
    comp <- generate.coalescent(run, pair[[1]], pair[[2]], current.time, is.bottleneck=TRUE)
    
    # update lineages
    lineages <- comp$get.lineages()
  }
  
  if (length(lineages) != bottleneck.size) {
    stop("Error in generate.bottleneck: @artpoon can't write while loops.")
  }
  
  return(lineages)
}


#' remove.lineage.pairs
#' 
#' This function removes lineage pairs in Run obj attr `choices`: list of lineage 
#' pair choices to coalesce.
#'
#' @param run = R6 Run object, one per simulation
#' @param lineage = Lineage object, to be removed from list of lineage pair choices
#'
#' @export
remove.lineage.pairs <- function(run, lineage) {
  # FIXME: should this be a member of Run object class?
  
  # extract all the pairs
  current.pairs <- run$get.pairs()
  
  # narrow down to only the compartment with lineage of interest
  compname <- lineage$get.location()$get.name()
  
  if (length(current.pairs) != 0) {
    comp.lineage.pairs <- unlist(sapply(1:length(current.pairs), function(x) {
      if (current.pairs[[x]] == compname) {names(current.pairs)[[x]]}
      else {NULL}
    }))
    
    # narrow down to only ones with given lineage in the name
    . <- sapply(comp.lineage.pairs, function(y) {
      split.names <- unlist(strsplit(y, '\\,'))
      if (lineage$get.name() %in% split.names) {
        # remove this pair of names from list attr `choices`
        run$remove.pair(split.names[1], split.names[2])
      }
    })
  }
}



#' add.lineage.pairs
#'
#' this function adds lineage pairs in MODEL obj attr `choices`: list of lineage 
#' pair choices to coalesce
#'
#' @param run = R6 Run object
#' @param lineage = Lineage object to be added to list of lineage pair choices
#' 
#' @export
add.lineage.pairs <- function(run, lineage) {
  
  host.comp <- lineage$get.location()$get.name()
  # find other lineages in this (host.comp) location
  other.lineages <- unlist(sapply(run$get.lineages(), function(x) {
    if (x$get.location()$get.name() == host.comp) {
      if (x$get.name() == lineage$get.name()) {NULL}
      else {x$get.name()}
    } else {NULL}
  }))
  
  # generate pairs with this new lineage and other lineages
  sapply(other.lineages, function(y) {
    run$add.pair(lineage$get.name(), y, host.comp)
  })
}
